# Migrating from SQLx to Diesel in top200-rs

This document outlines the steps required to migrate the `top200-rs` project from using `sqlx` to `diesel` for database interactions. Each step should be accompanied by tests that must pass before proceeding to the next.

1.  **Setup Diesel Dependencies and Configuration:**
    *   Remove `sqlx` from `Cargo.toml`.
    *   Add `diesel` to `Cargo.toml` with appropriate features (e.g., `sqlite`, `chrono`, `r2d2`).
    *   Install `diesel_cli` globally or ensure it's available in the development environment (`cargo install diesel_cli --no-default-features --features sqlite`).
    *   Create a `diesel.toml` file to configure the database URL and schema location.
    *   Update the `.env` file if necessary to reflect any changes in database URL format for Diesel (though `DATABASE_URL` is usually standard).

2.  **Establish Database Connection with Diesel:**
    *   Update the database connection logic (likely in `src/main.rs` or a dedicated DB module) to use Diesel's connection manager (e.g., `establish_connection` function).
    *   Implement a connection pool (e.g., using `r2d2`).
    *   Write a basic test to confirm a successful database connection using Diesel.

3.  **Set up Diesel Migrations:**
    *   Run `diesel setup` to create the migrations directory and initial schema file (`src/schema.rs`).
    *   Recreate existing `sqlx` migrations using `diesel_cli`. This involves:
        *   Generating new migration files with `diesel migration generate <migration_name>`.
        *   Copying the SQL from the existing `sqlx` migration files (`migrations/*.sql`) into the `up.sql` and `down.sql` files generated by Diesel.
    *   Run `diesel migration run` to apply the migrations.
    *   Write tests to verify that all tables and expected columns exist after running migrations.

4.  **Update Data Models for Diesel:**
    *   Modify existing data model structs (likely in `src/models.rs`) to be compatible with Diesel. This involves:
        *   Deriving `Queryable`, `Insertable`, `AsChangeset`, etc., as needed.
        *   Associating structs with database tables using `#[diesel(table_name = ...)]`.
        *   Ensuring field types align with Diesel's expectations and the `schema.rs` generated.
    *   Write tests for each model to ensure they can be queried (even if with mock data or an empty table initially).

5.  **Refactor Database Queries (Core Functionality):**
    *   Identify all modules and functions currently using `sqlx` for database operations (e.g., `src/marketcaps.rs`, `src/exchange_rates.rs`, `src/historical_marketcaps.rs`, `src/details_*.rs`).
    *   Rewrite these queries using Diesel's query DSL. This will be the most extensive part.
    *   Prioritize critical path functionality first, for example:
        *   Fetching and storing company details.
        *   Fetching and storing market cap data.
        *   Fetching and storing exchange rates.
    *   For each refactored function or logical group of queries:
        *   Write comprehensive unit and integration tests to ensure data is inserted, updated, and retrieved correctly.
        *   Verify data integrity and correctness against expected outcomes.

6.  **Update CLI Commands and Data Flow:**
    *   Modify the `clap` command handlers (in `src/main.rs` or related modules) that interact with the database to use the new Diesel-based functions.
    *   Ensure the data flow (fetch -> store -> report) works as expected with Diesel.
    *   Test each CLI command that involves database interaction to ensure it produces the correct output or performs the correct database operations. For example:
        *   `cargo run -- ExportCombined`
        *   `cargo run -- ListCurrencies`
        *   `cargo run -- FetchHistoricalMarketCaps 2022 2025`

7.  **Update Error Handling:**
    *   Adapt error handling for database operations to work with Diesel's error types (e.g., `diesel::result::Error`).
    *   Ensure that errors are propagated and handled gracefully throughout the application.
    *   Test various error scenarios (e.g., database connection failure, query errors, constraint violations).

8.  **Update Existing Tests:**
    *   Review and update all existing integration and unit tests in `tests/` directory that relied on `sqlx` to use Diesel.
    *   This might involve changing how test data is set up or how database assertions are made.
    *   Ensure all tests pass.

9.  **Code Cleanup and Refinement:**
    *   Remove any unused `sqlx`-related code, imports, or helper functions.
    *   Refactor Diesel query code for clarity and efficiency.
    *   Run `cargo fmt --all` and `cargo clippy` to ensure code quality and address any warnings.
    *   Run `cargo deny check` to check for dependency issues.

10. **Documentation Update:**
    *   Update `README.md`, `CLAUDE.md`, and any other relevant documentation to reflect the use of Diesel, including:
        *   Database setup instructions.
        *   Migration commands (`diesel migration run`, `diesel migration redo`, etc.).
        *   Notes on `diesel_cli`.